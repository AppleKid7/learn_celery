\documentclass[9pt]{beamer}
\usepackage{minted}
%\usemintedstyle{manni}
\usemintedstyle{murphy}
\usepackage{hyperref}
\hypersetup{
colorlinks=true,
urlcolor=blue
}
\usepackage{graphicx}

\begin{document}
\title{How to use Celery+RabbitMQ}
\author{Nick Thompson} 
\date{\today}

\frame{\titlepage}

\begin{frame}[fragile]
\frametitle{Getting started:}
\begin{minted}{bash}
$ git clone https://github.com/NAThompson/learn_celery.git
$ cd learn_celery
$ pip3 install -r requirements.txt
\end{minted}
\end{frame}

\begin{frame}[fragile]
  \frametitle{What will we attempt to accomplish?}
  
  \begin{itemize}
  \item Link Celery+RabbitMQ into Django ecosystem
    \pause
  \item Use tasks to keep page loads from timing out
    \pause
  \item Associate a running job with a progress bar
    \pause
  \item Link CPU cycles to billing
    \pause
  \item Autoscale nodes based on queue length
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Why Celery + RabbitMQ}
  \begin{itemize}
  \item Job scheduling is boring, and it's a pain.
    \pause
  \item So you certainly don't want to learn \emph{two} job schedulers
    \pause
  \item You never want to be in a spot where you have to swap out your job scheduler
    \pause
  \item Therefore, use the most well-tested and popular stack
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{What is RabbitMQ?}
  \begin{itemize}
  \item RabbitMQ is an implementation of the \emph{advanced messaged queuing protocol} (AMQP), a standardized way to pass data between applications.
  \item The specification of AMQP is \href{http://www.amqp.org/specification/0-10/amqp-org-download}{300 pages long}, but it's basically an email server protocal for binary applications
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{How do I set up RabbitMQ?}
  \begin{minted}{bash}
    $ sudo apt-get install -y rabbitmq-server
    $ sudo rabbitmqctl status
    $ sudo lsof -i :5672 # 5672 is the well-known port of AMQP
  \end{minted}
  If your server still isn't up, or you need to restart it:
  \begin{minted}{bash}
    $ sudo rabbitmq-server -detached 
  \end{minted}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Testing RabbitMQ}
  We want to get the minimal working RabbitMQ working on localhost:
  \begin{minted}{bash}
    $ rabbitmqctl list_queues
    Listing queues ...
    $ python3 basic_rabbitmq/send_message.py
    We have sent the message 'Hello World' to RabbitMQ
    $ rabbitmqctl list_queues
    Listing queues ...
    hello 1
    $ python3 basic_rabbitmq/send_message.py
    We have sent the message 'Hello World' to RabbitMQ
    $ rabbitmqclt list_queues
    Listing queues ...
    hello 2
  \end{minted}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Receive the messages:}
  \begin{minted}{bash}
    learn_celery$ python3 basic_rabbitmq/receive_message.py
    Waiting for messages. To exit press CTRL+C
    [x] Received (b'Hello World',)
    [x] Received$ (b'Hello World',)
    learn_celery rabbitmqctl list_queues
    Listing queues ...
    hello 0
  \end{minted}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Deleting a queue}
  As you learn RabbitMQ, you start generating meaningless queues that you might want to get rid of. Here's how to delete them:
  \begin{minted}{bash}
    learn_celery$ rabbitmqctl list_queues
    Listing queues ...
    hello 0
    (learn_celery) ~/learn_celery$ rabbitmqctl stop_app
    Stopping node 'rabbit@nthompson-Precision-M6700' ...
    (learn_celery) ~/learn_celery$ rabbitmqctl reset
    Resetting node 'rabbit@nthompson-Precision-M6700' ...
    (learn_celery) ~/learn_celery$ rabbitmqctl start_app
    Starting node 'rabbit@nthompson-Precision-M6700' ...
    (learn_celery) ~/learn_celery$ rabbitmqctl list_queues
    Listing queues ...
  \end{minted}
\end{frame}

\begin{frame}[fragile]
  \frametitle{On to Celery}
  \begin{itemize}
  \item You could connect to your RabbitMQ directly, without Celery, but there's a lot of boilerplate.
  \item Celery makes a nice glue between your Django and Rabbitmq.
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Celery Basic Example}
  \begin{minted}{bash}
    $ cd basic_celery
    $ celery --app=task work --loglevel=info &
    $ python3 -q
    >>> from tasks import add
    >>> r = add.delay(12, 12)
    [2015-11-05 14:16:07,806: INFO/MainProcess] Received task: tasks.add[4f2c482f-5e66-4118-89bc-5e1ff6b06111]
    [2015-11-05 14:16:07,816: INFO/MainProcess] Task tasks.add[4f2c482f-5e66-4118-89bc-5e1ff6b06111] succeeded in 0.009626324999771896s: 24
    >>> r.status
    'SUCCESS'
    >>> r.result
    24
  \end{minted}
  Easy peasy.
\end{frame}

\begin{frame}[fragile]
  \frametitle{Celery Basic Example}
  Celery will start some queues in RabbitMQ after startup:
  \begin{minted}{bash}
    # rabbitmqctl list_queues
    Listing queues ...
    celery0
    celery@nthompson-Precision-M6700.celery.pidbox0
    celeryev.39a8ba96-9ed0-4b31-83a3-0728cb6273c50
  \end{minted}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Multiple workers}
  Celery has support for multiple workers:
  \begin{minted}{bash}
    celery --app=tasks worker --loglevel=INFO --concurrency=`nproc`
    -------------- celery@nthompson-Precision-M6700 v3.1.19 (Cipater)
    ---- **** -----
    --- * ***  * -- Linux-3.19.0-32-generic-x86_64-with-Ubuntu-15.04-vivid
    -- * - **** ---
    - ** ---------- [config]
    - ** ---------- .> app:         tasks:0x7feabb181128
    - ** ---------- .> transport:   amqp://guest:**@localhost:5672//
    - ** ---------- .> results:     rpc://
    - *** --- * --- .> concurrency: 8 (prefork)
    -- ******* ----
    --- ***** ----- [queues]
    -------------- .> celery           exchange=celery(direct) key=celery
  \end{minted}
  The default concurrency is nproc.
\end{frame}

\begin{frame}[fragile]
  \frametitle{Embedding into Django}
  
\end{frame}

\end{document}
