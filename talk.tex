\documentclass[9pt]{beamer}
\usepackage{minted}
%\usemintedstyle{manni}
\usemintedstyle{murphy}
\usepackage{hyperref}
\hypersetup{
colorlinks=true,
urlcolor=blue
}
\usepackage{graphicx}

\begin{document}
\title{How to use Celery+RabbitMQ}
\author{Nick Thompson} 
\date{\today}

\frame{\titlepage}

\begin{frame}[fragile]
\frametitle{Getting started:}
\begin{minted}{bash}
$ git clone https://github.com/NAThompson/learn_celery.git
$ cd learn_celery
$ pip3 install -r requirements.txt
\end{minted}
\end{frame}

\begin{frame}[fragile]
  \frametitle{What will we attempt to accomplish?}
  
  \begin{itemize}
  \item Link Celery+RabbitMQ into Django ecosystem
    \pause
  \item Use tasks to keep page loads from timing out
    \pause
  \item Associate a running job with a progress bar
    \pause
  \item Link CPU cycles to billing
    \pause
  \item Autoscale nodes based on queue length
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Why Celery + RabbitMQ}
  \begin{itemize}
  \item Job scheduling is boring, and it's a pain.
    \pause
  \item So you certainly don't want to learn \emph{two} job schedulers
    \pause
  \item You never want to be in a spot where you have to swap out your job scheduler
    \pause
  \item Therefore, use the most well-tested and popular stack
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{What is RabbitMQ?}
  \begin{itemize}
  \item RabbitMQ is an implementation of the \emph{advanced messaged queuing protocol} (AMQP), a standardized way to pass data between applications.
  \item The specification of AMQP is \href{http://www.amqp.org/specification/0-10/amqp-org-download}{300 pages long}, but it's basically an email server protocal for binary applications
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Warning!}
  \begin{itemize}
  \item Celery as an API is a bit baffling
    \pause
  \item Many people contend that using RabbitMQ directly leads to less astonishment
    \pause
  \item The author has never tried RabbitMQ directly, but has been astonished many times by Celery. So keep this in mind as an option.
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{How do I set up RabbitMQ?}
  \begin{minted}{bash}
    $ sudo apt-get install -y rabbitmq-server
    $ sudo rabbitmqctl status
    $ sudo lsof -i :5672 # 5672 is the well-known port of AMQP
  \end{minted}
  If your server still isn't up, or you need to restart it:
  \begin{minted}{bash}
    $ sudo rabbitmq-server -detached 
  \end{minted}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Testing RabbitMQ}
  We want to get the minimal working RabbitMQ working on localhost:
  \begin{minted}{bash}
    $ rabbitmqctl list_queues
    Listing queues ...
    $ python3 basic_rabbitmq/send_message.py
    We have sent the message 'Hello World' to RabbitMQ
    $ rabbitmqctl list_queues
    Listing queues ...
    hello 1
    $ python3 basic_rabbitmq/send_message.py
    We have sent the message 'Hello World' to RabbitMQ
    $ rabbitmqclt list_queues
    Listing queues ...
    hello 2
  \end{minted}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Receive the messages:}
  \begin{minted}{bash}
    learn_celery$ python3 basic_rabbitmq/receive_message.py
    Waiting for messages. To exit press CTRL+C
    [x] Received (b'Hello World',)
    [x] Received$ (b'Hello World',)
    learn_celery rabbitmqctl list_queues
    Listing queues ...
    hello 0
  \end{minted}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Deleting a queue}
  As you learn RabbitMQ, you start generating meaningless queues that you might want to get rid of. Here's how to delete them:
  \begin{minted}{bash}
    learn_celery$ rabbitmqctl list_queues
    Listing queues ...
    hello 0
    (learn_celery) ~/learn_celery$ rabbitmqctl stop_app
    Stopping node 'rabbit@nthompson-Precision-M6700' ...
    (learn_celery) ~/learn_celery$ rabbitmqctl reset
    Resetting node 'rabbit@nthompson-Precision-M6700' ...
    (learn_celery) ~/learn_celery$ rabbitmqctl start_app
    Starting node 'rabbit@nthompson-Precision-M6700' ...
    (learn_celery) ~/learn_celery$ rabbitmqctl list_queues
    Listing queues ...
  \end{minted}
\end{frame}

\begin{frame}[fragile]
  \frametitle{On to Celery}
  \begin{itemize}
  \item You could connect to your RabbitMQ directly, without Celery, but there's a lot of boilerplate.
  \item Celery makes a nice glue between your Django and Rabbitmq.
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Celery Basic Example}
  \begin{minted}{bash}
    $ cd basic_celery
    $ celery --app=task work --loglevel=info &
    $ python3 -q
    >>> from tasks import add
    >>> r = add.delay(12, 12)
    [2015-11-05 14:16:07,806: INFO/MainProcess] Received task: tasks.add[4f2c482f-5e66-4118-89bc-5e1ff6b06111]
    [2015-11-05 14:16:07,816: INFO/MainProcess] Task tasks.add[4f2c482f-5e66-4118-89bc-5e1ff6b06111] succeeded in 0.009626324999771896s: 24
    >>> r.status
    'SUCCESS'
    >>> r.result
    24
  \end{minted}
  Easy peasy.
\end{frame}

\begin{frame}[fragile]
  \frametitle{Celery Basic Example}
  Celery will start some queues in RabbitMQ after startup:
  \begin{minted}{bash}
    # rabbitmqctl list_queues
    Listing queues ...
    celery0
    celery@nthompson-Precision-M6700.celery.pidbox0
    celeryev.39a8ba96-9ed0-4b31-83a3-0728cb6273c50
  \end{minted}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Multiple workers}
  Celery has support for multiple workers:
  \begin{minted}{bash}
    celery --app=tasks worker --loglevel=INFO --concurrency=`nproc`
    -------------- celery@nthompson-Precision-M6700 v3.1.19 (Cipater)
    ---- **** -----
    --- * ***  * -- Linux-3.19.0-32-generic-x86_64-with-Ubuntu-15.04-vivid
    -- * - **** ---
    - ** ---------- [config]
    - ** ---------- .> app:         tasks:0x7feabb181128
    - ** ---------- .> transport:   amqp://guest:**@localhost:5672//
    - ** ---------- .> results:     rpc://
    - *** --- * --- .> concurrency: 8 (prefork)
    -- ******* ----
    --- ***** ----- [queues]
    -------------- .> celery           exchange=celery(direct) key=celery
  \end{minted}
  The default concurrency is nproc.
\end{frame}

\begin{frame}[fragile]
  \frametitle{Embedding Celery into Django}
  It's not a huge jump from this to embedding in Django:
  \begin{itemize}
  \item Specify the serialization types you'll accept in settings.py:
    \begin{minted}{python}
      CELERY_ACCEPT_CONTENT = ['json']
      CELERY_TASK_SERIALIZER = 'json'
      CELERY_RESULT_SERIALIZER = 'json'
    \end{minted}
    \pause
  \item Specify the broker url in settings.py
    \begin{minted}{python}
      BROKER_URL = 'amqp://guest:guest@localhost//'
    \end{minted}
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Embedding Celery into Django}
  \begin{itemize}
  \item Start a app and add some tasks to it:
    \begin{minted}{bash}
      $ ./manage.py startapp jobs
      $ touch jobs/tasks.py # Define a task in here. Must be named tasks.py.
    \end{minted}
    \pause
  \item Add your app to INSTALLED\_APPS in settings.py, and
    \begin{minted}{bash}
      echo "from .celery import app as celery_app  # noqa" >> __init__.py
    \end{minted}
    \pause
  \item Now start up celery:
    \begin{minted}{bash}
      $ celery --app=celery_in_django worker --concurrency=`nproc` --loglevel=INFO &
    \end{minted}
  \end{itemize}
  You should see your task registered in the logs.
\end{frame}

\begin{frame}[fragile]
  \frametitle{Minimal Django+Celery Example:}
  Assuming you have RabbitMQ up, then:
  \begin{minted}{bash}
  learn_celery$ git checkout basic_async_task
  learn_celery$ cd django_example
  django_example$ celery --app=celery_in_django worker --concurrency=`nproc` --loglevel=info &
  django_example$ ./manage.py runserver
  \end{minted}
  Now navigate to 127.0.0.1:8000, and start hitting buttons.
\end{frame}

\begin{frame}[fragile]
  \frametitle{Not-as-minimal Django+Celery Example}
  Problems with the minimal example:
  \begin{itemize}
  \item The user gets no feedback when he's pressed a button; as such might press it 40 times
    \pause
  \item The user doesn't know when the task is done
    \pause
  \item The user doesn't know how much to estimate how long the job will run
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Take 1: Store tasks in the session}
  This is a low-effort, effective for some tasks method:
  \begin{itemize}
  \item Store task id in request.session; the use the task id as an argument to celery.result.AsyncResult constructor.
    \pause
  \item Then we make buttons available based on task status:
    \begin{minted}{bash}
      $ git checkout task_in_session
      $ cd django_example
      $ ./manage.py runserver
    \end{minted}
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Take 1: Store tasks in the session}
  This is not a foolproof design, as the session should expire at browser close.
\end{frame}

\end{document}
